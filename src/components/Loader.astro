---
// Loader.astro
---

<div id="loader" class="loader">

  <svg class="loader__image" viewBox="0 0 48 47" fill="none" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
    <path d="M31.2817 13.5478L42.1955 8.50565L48 22.3584L36.8776 27.2609L44.8023 37.2579L33.1586 46.6093L24 35.0247L14.8414 46.6093L3.30195 37.3625L11.4352 27.3656L0 22.3584L6.11729 8.50565L16.701 13.3384L16.5967 0.829102H31.386L31.2817 13.5478Z" stroke="#fff" stroke-width="1" fill="none" vector-effect="non-scaling-stroke"/>
  </svg>
  
  <div class="count-wrapper">
    <div class="count">
      <div class="digit">
        <h1>9</h1>
      </div>
      <div class="digit">
        <h1>8</h1>
      </div>
      <div class="digit">
        <h1>7</h1>
      </div>
      <div class="digit">
        <h1>4</h1>
      </div>
      <div class="digit">
        <h1>2</h1>
      </div>
      <div class="digit">
        <h1>0</h1>
      </div>
    </div>
  </div>

  <div class="count-wrapper">
    <div class="count">
      <div class="digit">
        <h1>9</h1>
      </div>
      <div class="digit">
        <h1>5</h1>
      </div>
      <div class="digit">
        <h1>9</h1>
      </div>
      <div class="digit">
        <h1>7</h1>
      </div>
      <div class="digit">
        <h1>4</h1>
      </div>
      <div class="digit">
        <h1>0</h1>
      </div>
    </div>
  </div>

  
</div>

<script>
  import { waitForCriticalImages } from '../scripts/utils/images-ready.js';
  import gsap from 'gsap';

  // Wait for fonts and critical images to load before removing loader
  async function initLoader() {
    const loader = document.getElementById('loader');
    if (!loader) return;

    const startTime = Date.now();
    const minDisplayTime = 1500; // 1.5 segundos m√≠nimo total

    try {
      // Wait for fonts
      await new Promise<void>((resolve) => {
        const handleFontsReady = () => {
          resolve();
        };
        
        window.addEventListener('fontsReady', handleFontsReady, { once: true });
        
        // Fallback for fonts
        document.fonts.ready.then(() => {
          setTimeout(() => {
            if (!(window as any).fontsReadyDispatched) {
              resolve();
            }
          }, 100);
        });
      });
      
      // Wait for critical images
      await new Promise<void>((resolve) => {
        waitForCriticalImages(() => {
          resolve();
        });
      });
      
      // Additional wait to ensure everything is fully rendered
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Calculate remaining time to ensure minimum display time
      const elapsed = Date.now() - startTime;
      const remaining = Math.max(0, minDisplayTime - elapsed);
      
      // Wait for remaining time if needed
      if (remaining > 0) {
        await new Promise(resolve => setTimeout(resolve, remaining));
      }
      
      // Get loader image
      const loaderImage = document.querySelector('.loader__image') as HTMLElement;
      
      // Start the countdown animation
      const countElements = document.querySelectorAll(".count");
      const wrapperElements = document.querySelectorAll(".count-wrapper");
      
      if (countElements.length === 0 || wrapperElements.length === 0) {
        console.warn('Loader: Count elements not found');
        // Fallback: animate loader exit
        if (loaderImage) {
          gsap.to(loaderImage, {
            y: '-100vh',
            opacity: 0,
            duration: 1,
            ease: 'power3.inOut',
          });
        }
        gsap.to(loader, {
          clipPath: 'inset(0 0 100% 0)',
          duration: 1,
          ease: 'power3.inOut',
          onComplete: () => {
            window.dispatchEvent(new CustomEvent('loaderComplete'));
            loader.remove();
          }
        });
        return;
      }

      const windowWidth = window.innerWidth;
      const wrapperWidth = 180;
      const finalPosition = windowWidth - wrapperWidth;
      const stepDistance = finalPosition / 6;
      
      let animationCompleted = false;
      
      const tl = gsap.timeline({
        delay: 0.5,
        repeat: 0, // No repeat
        onComplete: () => {
          if (animationCompleted) return; // Prevent multiple calls
          animationCompleted = true;
          
          // Mark that assets are ready and dispatch custom events
          (window as any).fontsReadyDispatched = true;
          window.dispatchEvent(new CustomEvent('fontsReady'));
          window.dispatchEvent(new CustomEvent('assetsReady'));
          
          // Animate image exit (up and out, no scale)
          if (loaderImage) {
            gsap.to(loaderImage, {
              y: '-100vh',
              opacity: 0,
              duration: 1,
              ease: 'power3.inOut',
            });
          }
          
          // Animate loader exit as curtain going up
          gsap.to(loader, {
            clipPath: 'inset(0 0 100% 0)', // Reveal from bottom (curtain going up)
            duration: 1,
            ease: 'power3.inOut',
            onComplete: () => {
              // Dispatch event when loader animation completes
              window.dispatchEvent(new CustomEvent('loaderComplete'));
              loader.remove();
            }
          });
        }
      });

      tl.to(".count", {
        x: -900,
        duration: 0.85,
        ease: "power4.inOut",
      });

      for (let i = 1; i <= 6; i++) {
        const xPosition = -900 + i * 180;
        tl.to(".count", {
          x: xPosition,
          duration: 0.85,
          ease: "power4.inOut",
        });
        
        // Animate wrapper at the same time
        tl.to(".count-wrapper", {
          x: stepDistance * i,
          duration: 0.85,
          ease: "power4.inOut",
        }, "<"); // Start at the same time as previous animation
      }
      
    } catch (error) {
      console.warn('Asset loading error:', error);
      // Even if there's an error, ensure minimum display time
      const elapsed = Date.now() - startTime;
      const remaining = Math.max(0, minDisplayTime - elapsed);
      
      setTimeout(() => {
        (window as any).fontsReadyDispatched = true;
        window.dispatchEvent(new CustomEvent('fontsReady'));
        window.dispatchEvent(new CustomEvent('assetsReady'));
        
        // Animate image exit
        const loaderImage = document.querySelector('.loader__image') as HTMLElement;
        if (loaderImage) {
          gsap.to(loaderImage, {
            y: '-100vh',
            opacity: 0,
            duration: 1,
            ease: 'power3.inOut',
          });
        }
        
        // Animate loader exit as curtain going up
        gsap.to(loader, {
          clipPath: 'inset(0 0 100% 0)',
          duration: 1,
          ease: 'power3.inOut',
          onComplete: () => {
            window.dispatchEvent(new CustomEvent('loaderComplete'));
            loader.remove();
          }
        });
      }, remaining);
    }
  }

  // Initialize loader image rotation
  function initLoaderImageRotation() {
    const loaderImage = document.querySelector('.loader__image') as HTMLElement;
    if (loaderImage) {
      gsap.to(loaderImage, {
        rotation: 360,
        duration: 8, // Slower rotation
        ease: 'none',
        repeat: -1,
      });
    }
  }

  // Initialize loader when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initLoaderImageRotation();
      initLoader();
    });
  } else {
    initLoaderImageRotation();
    initLoader();
  }
</script>
 

<style>
  .loader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #032746;
  color: #fff;
  display: flex;
  align-items: flex-end;
  overflow: hidden;
  clip-path: inset(0 0 0 0); /* Initial state - fully visible */
  will-change: clip-path;
  z-index: 9999;
}

.count-wrapper {
  position: relative;
  width: 180px;
  height: 360px;
  clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
  will-change: transform;
}

.count {
  position: relative;
  width: 1080px;
  height: 360px;
  display: flex;
  justify-content: space-between;
  transform: translateX(-1080px);
  will-change: transform;
}

.digit {
  position: relative;
  width: 180px;
  height: 360px;
}

.digit h1 {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: max-content;
  font-size: 300px;
  font-weight: 700;
  line-height: 1;
}

.loader__image {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 120vh;
  height: 120vh;
  opacity: 0.15;
  z-index: 10;
  will-change: transform, opacity;
}

</style>