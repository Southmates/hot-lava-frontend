---
// Loader.astro
---

<div id="loader" class="loader">
  <div class="count-wrapper">
    <div class="count">
      <div class="digit">
        <h1>9</h1>
      </div>
      <div class="digit">
        <h1>8</h1>
      </div>
      <div class="digit">
        <h1>7</h1>
      </div>
      <div class="digit">
        <h1>4</h1>
      </div>
      <div class="digit">
        <h1>2</h1>
      </div>
      <div class="digit">
        <h1>0</h1>
      </div>
    </div>
  </div>

  <div class="count-wrapper">
    <div class="count">
      <div class="digit">
        <h1>9</h1>
      </div>
      <div class="digit">
        <h1>5</h1>
      </div>
      <div class="digit">
        <h1>9</h1>
      </div>
      <div class="digit">
        <h1>7</h1>
      </div>
      <div class="digit">
        <h1>4</h1>
      </div>
      <div class="digit">
        <h1>0</h1>
      </div>
    </div>
  </div>

  
</div>

<script>
  import { waitForCriticalImages } from '../scripts/utils/images-ready.js';
  import gsap from 'gsap';

  // Wait for fonts and critical images to load before removing loader
  async function initLoader() {
    const loader = document.getElementById('loader');
    if (!loader) return;

    const startTime = Date.now();
    const minDisplayTime = 1500; // 1.5 segundos m√≠nimo total

    try {
      // Wait for fonts
      await new Promise<void>((resolve) => {
        const handleFontsReady = () => {
          resolve();
        };
        
        window.addEventListener('fontsReady', handleFontsReady, { once: true });
        
        // Fallback for fonts
        document.fonts.ready.then(() => {
          setTimeout(() => {
            if (!(window as any).fontsReadyDispatched) {
              resolve();
            }
          }, 100);
        });
      });
      
      // Wait for critical images
      await new Promise<void>((resolve) => {
        waitForCriticalImages(() => {
          resolve();
        });
      });
      
      // Additional wait to ensure everything is fully rendered
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Calculate remaining time to ensure minimum display time
      const elapsed = Date.now() - startTime;
      const remaining = Math.max(0, minDisplayTime - elapsed);
      
      // Wait for remaining time if needed
      if (remaining > 0) {
        await new Promise(resolve => setTimeout(resolve, remaining));
      }
      
      // Start the countdown animation
      const countElements = document.querySelectorAll(".count");
      const wrapperElements = document.querySelectorAll(".count-wrapper");
      
      if (countElements.length === 0 || wrapperElements.length === 0) {
        console.warn('Loader: Count elements not found');
        // Fallback: animate loader exit
        gsap.to(loader, {
          clipPath: 'inset(0 0 100% 0)',
          duration: 1,
          ease: 'power3.inOut',
          onComplete: () => {
            window.dispatchEvent(new CustomEvent('loaderComplete'));
            loader.remove();
          }
        });
        return;
      }

      const windowWidth = window.innerWidth;
      const wrapperWidth = 180;
      const finalPosition = windowWidth - wrapperWidth;
      const stepDistance = finalPosition / 6;
      
      let animationCompleted = false;
      
      const tl = gsap.timeline({
        delay: 0.5,
        repeat: 0, // No repeat
        onComplete: () => {
          if (animationCompleted) return; // Prevent multiple calls
          animationCompleted = true;
          
          // Mark that assets are ready and dispatch custom events
          (window as any).fontsReadyDispatched = true;
          window.dispatchEvent(new CustomEvent('fontsReady'));
          window.dispatchEvent(new CustomEvent('assetsReady'));
          
          // Animate loader exit as curtain going up
          gsap.to(loader, {
            clipPath: 'inset(0 0 100% 0)', // Reveal from bottom (curtain going up)
            duration: 1,
            ease: 'power3.inOut',
            onComplete: () => {
              // Dispatch event when loader animation completes
              window.dispatchEvent(new CustomEvent('loaderComplete'));
              loader.remove();
            }
          });
        }
      });

      tl.to(".count", {
        x: -900,
        duration: 0.85,
        ease: "power4.inOut",
      });

      for (let i = 1; i <= 6; i++) {
        const xPosition = -900 + i * 180;
        tl.to(".count", {
          x: xPosition,
          duration: 0.85,
          ease: "power4.inOut",
        });
        
        // Animate wrapper at the same time
        tl.to(".count-wrapper", {
          x: stepDistance * i,
          duration: 0.85,
          ease: "power4.inOut",
        }, "<"); // Start at the same time as previous animation
      }
      
    } catch (error) {
      console.warn('Asset loading error:', error);
      // Even if there's an error, ensure minimum display time
      const elapsed = Date.now() - startTime;
      const remaining = Math.max(0, minDisplayTime - elapsed);
      
      setTimeout(() => {
        (window as any).fontsReadyDispatched = true;
        window.dispatchEvent(new CustomEvent('fontsReady'));
        window.dispatchEvent(new CustomEvent('assetsReady'));
        
        // Animate loader exit as curtain going up
        gsap.to(loader, {
          clipPath: 'inset(0 0 100% 0)',
          duration: .5,
          ease: 'power4.inOut',
          onComplete: () => {
            window.dispatchEvent(new CustomEvent('loaderComplete'));
            loader.remove();
          }
        });
      }, remaining);
    }
  }

  // Initialize loader when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initLoader);
  } else {
    initLoader();
  }
</script>
 

<style>
  .loader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #032746;
  color: #fff;
  display: flex;
  align-items: flex-end;
  overflow: hidden;
  clip-path: inset(0 0 0 0); /* Initial state - fully visible */
  will-change: clip-path;
  z-index: 9999;
}

.count-wrapper {
  position: relative;
  width: 180px;
  height: 360px;
  clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
  will-change: transform;
}

.count {
  position: relative;
  width: 1080px;
  height: 360px;
  display: flex;
  justify-content: space-between;
  transform: translateX(-1080px);
  will-change: transform;
}

.digit {
  position: relative;
  width: 180px;
  height: 360px;
}

.digit h1 {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: max-content;
  font-size: 300px;
  font-weight: 700;
  line-height: 1;
}

</style>