---
// canvas.astro
---

<div class="gradient-canvas"></div>

<script>
  import * as THREE from "three";
  import { vertexShader, fluidShader, displayShader } from '../scripts/shaders.js';
  
  const config = {
    brushSize: 25.0,
    brushStrength: 0.5,
    distortionAmount: 2.5,
    fluidDecay: 0.98,
    trailLength: 0.8,
    stopDecay: 0.85,
    color1: "#FBC346",
    color2: "#F17D3A",
    color3: "#ED522D",
    color4: "#F59C3F",
    colorIntensity: 1.0,
    softness: 1.0,
  };

  function hexToRgb(hex: string): [number, number, number] {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    return [r, g, b];
  }

  function isIOSLike(): boolean {
    const ua = navigator.userAgent || '';
    const iOS = /iP(hone|od|ad)/.test(ua);
    // iPadOS reports as Mac; detect touch-capable "MacIntel"
    const iPadOS = navigator.platform === 'MacIntel' && (navigator.maxTouchPoints || 0) > 1;
    return iOS || iPadOS;
  }

  function initCanvas() {
    const gradientCanvas = document.querySelector(".gradient-canvas");
    if (!gradientCanvas) {
      console.warn("Canvas element not found, retrying...");
      setTimeout(initCanvas, 100);
      return;
    }
    
    // console.log("Initializing WebGL canvas...");

    // iOS Safari is prone to WebGL memory/context crashes with float render targets + high DPR.
    // Prefer stability: cap DPR and avoid FloatType on iOS-like devices.
    const ios = isIOSLike();
    const maxDpr = ios ? 1.5 : 2;
    const dpr = Math.min(window.devicePixelRatio || 1, maxDpr);
    const renderScale = ios ? 0.5 : 1; // lower internal resolution on iOS
    const textureType = ios ? THREE.UnsignedByteType : THREE.HalfFloatType;

    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const renderer = new THREE.WebGLRenderer({
      antialias: !ios,
      powerPreference: ios ? 'low-power' : 'high-performance',
      alpha: true,
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(dpr);
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    renderer.domElement.style.display = 'block';
    gradientCanvas.appendChild(renderer.domElement);
   
    // console.log("Canvas element added to DOM:", renderer.domElement);

    let rafId = 0;
    let stopped = false;

    // If the WebGL context is lost (common on iOS under memory pressure), stop animating
    // so the browser can recover instead of crashing/reloading.
    renderer.domElement.addEventListener(
      'webglcontextlost',
      (e: WebGLContextEvent) => {
        e.preventDefault();
        stopped = true;
        if (rafId) cancelAnimationFrame(rafId);
      },
      { passive: false }
    );

    // Compute offscreen target size (smaller on iOS to reduce memory).
    const getTargetSize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      return {
        width: Math.max(2, Math.floor(width * renderScale)),
        height: Math.max(2, Math.floor(height * renderScale)),
      };
    };

    const { width: targetW, height: targetH } = getTargetSize();

    const fluidTarget1 = new THREE.WebGLRenderTarget(
      targetW,
      targetH,
      {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: textureType,
      }
    );

    const fluidTarget2 = new THREE.WebGLRenderTarget(
      targetW,
      targetH,
      {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: textureType,
      }
    );

    let currentFluidTarget = fluidTarget1;
    let previousFluidTarget = fluidTarget2;
    let frameCount = 0;

    const fluidMaterial = new THREE.ShaderMaterial({
      uniforms: {
        iTime: { value: 0 },
        iResolution: {
          value: new THREE.Vector2(targetW, targetH),
        },
        iMouse: { value: new THREE.Vector4(0, 0, 0, 0) },
        iFrame: { value: 0 },
        iPreviousFrame: { value: null },
        uBrushSize: { value: config.brushSize },
        uBrushStrength: { value: config.brushStrength },
        uFluidDecay: { value: config.fluidDecay },
        uTrailLength: { value: config.trailLength },
        uStopDecay: { value: config.stopDecay },
      },
      vertexShader: vertexShader,
      fragmentShader: fluidShader,
    });

    const displayMaterial = new THREE.ShaderMaterial({
      uniforms: {
        iTime: { value: 0 },
        iResolution: {
          value: new THREE.Vector2(targetW, targetH),
        },
        iFluid: { value: null },
        uDistortionAmount: { value: config.distortionAmount },
        uColor1: { value: new THREE.Vector3(...hexToRgb(config.color1)) },
        uColor2: { value: new THREE.Vector3(...hexToRgb(config.color2)) },
        uColor3: { value: new THREE.Vector3(...hexToRgb(config.color3)) },
        uColor4: { value: new THREE.Vector3(...hexToRgb(config.color4)) },
        uColorIntensity: { value: config.colorIntensity },
        uSoftness: { value: config.softness },
      },
      vertexShader: vertexShader,
      fragmentShader: displayShader,
    });

    const geometry = new THREE.PlaneGeometry(2, 2);
    const fluidPlane = new THREE.Mesh(geometry, fluidMaterial);
    const displayPlane = new THREE.Mesh(geometry, displayMaterial);

    let mouseX = 0,
      mouseY = 0;
    let prevMouseX = 0,
      prevMouseY = 0;
    let lastMoveTime = 0;

    document.addEventListener("mousemove", (e) => {
      const rect = gradientCanvas.getBoundingClientRect();
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX - rect.left;
      mouseY = rect.height - (e.clientY - rect.top);
      lastMoveTime = performance.now();
      fluidMaterial.uniforms.iMouse.value.set(
        mouseX,
        mouseY,
        prevMouseX,
        prevMouseY
      );
    });

    document.addEventListener("mouseleave", () => {
      fluidMaterial.uniforms.iMouse.value.set(0, 0, 0, 0);
    });

    function animate() {
      if (stopped) return;
      rafId = requestAnimationFrame(animate);

      const time = performance.now() * 0.001;
      fluidMaterial.uniforms.iTime.value = time;
      displayMaterial.uniforms.iTime.value = time;
      fluidMaterial.uniforms.iFrame.value = frameCount;

      if (performance.now() - lastMoveTime > 100) {
        fluidMaterial.uniforms.iMouse.value.set(0, 0, 0, 0);
      }

      fluidMaterial.uniforms.uBrushSize.value = config.brushSize;
      fluidMaterial.uniforms.uBrushStrength.value = config.brushStrength;
      fluidMaterial.uniforms.uFluidDecay.value = config.fluidDecay;
      fluidMaterial.uniforms.uTrailLength.value = config.trailLength;
      fluidMaterial.uniforms.uStopDecay.value = config.stopDecay;

      displayMaterial.uniforms.uDistortionAmount.value = config.distortionAmount;
      displayMaterial.uniforms.uColorIntensity.value = config.colorIntensity;
      displayMaterial.uniforms.uSoftness.value = config.softness;
      displayMaterial.uniforms.uColor1.value.set(...hexToRgb(config.color1));
      displayMaterial.uniforms.uColor2.value.set(...hexToRgb(config.color2));
      displayMaterial.uniforms.uColor3.value.set(...hexToRgb(config.color3));
      displayMaterial.uniforms.uColor4.value.set(...hexToRgb(config.color4));

      fluidMaterial.uniforms.iPreviousFrame.value = previousFluidTarget.texture;
      renderer.setRenderTarget(currentFluidTarget);
      renderer.render(fluidPlane, camera);

      displayMaterial.uniforms.iFluid.value = currentFluidTarget.texture;
      renderer.setRenderTarget(null);
      renderer.render(displayPlane, camera);

      const temp = currentFluidTarget;
      currentFluidTarget = previousFluidTarget;
      previousFluidTarget = temp;

      frameCount++;
    }

    window.addEventListener("resize", () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      const { width: tw, height: th } = getTargetSize();

      renderer.setSize(width, height);
      renderer.setPixelRatio(dpr);
      fluidMaterial.uniforms.iResolution.value.set(tw, th);
      displayMaterial.uniforms.iResolution.value.set(tw, th);

      fluidTarget1.setSize(tw, th);
      fluidTarget2.setSize(tw, th);
      frameCount = 0;
    });

    // Start animation; if anything throws (e.g. unsupported RT formats), fail softly.
    try {
      animate();
    } catch (err) {
      stopped = true;
      if (rafId) cancelAnimationFrame(rafId);
      console.warn('Gradient canvas disabled due to WebGL error:', err);
      renderer.dispose();
      if (renderer.domElement?.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
    }
   
    // console.log("WebGL canvas initialized successfully");
  }

  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCanvas);
  } else {
    // DOM is already ready, but wait a bit to ensure element exists
    setTimeout(initCanvas, 100);
  }
</script>

<style>
  /* Canvas */
  .gradient-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index:999;
    pointer-events: none; 
    z-index: -1;

    /* opacity: .75; 
    filter: blur(1px) invert(1);
    mix-blend-mode: overlay; */
 
    opacity: .875;
    filter: blur(10px) invert(0) saturate(0);
    mix-blend-mode: overlay;

  }
</style>